## Лабораторная работа №2
### Студент: Мазайкина Мария Дмитриевна
### Группа: P3309

## Описание
Функциональная полиморфная библиотека мультимножества на основе префиксного дерева.

Структура данных хранит элементы и количество их вхождений. Реализация параметризуется (через Функтор `Make`) модулем `Elt`, описывающим тип элемента и способ его разбиения на компоненты (например, число разбивается на цифры).

Ключевые особенности:
- **Неизменяемость:** Все операции возвращают новую версию дерева, старая остается доступной.
- **Полиморфизм:** Работает с любыми типами данных, для которых можно определить функции `split` (разбиение на части) и `join`.
- **Эффективность:** Сравнение (`equal`, `compare`) и объединение (`merge`) работают структурно, не требуя преобразования дерева в плоские списки.
- **Моноид:** Структура обладает нейтральным элементом (`empty`) и ассоциативной операцией слияния (`merge`).

## Структура репозитория
```
├── dune-project
├── src
│   ├── dune  
│   ├── prefix_tree.mli - интерфейс
│   └── prefix_tree.ml - реализация
└── test
    ├── dune 
    ├── tests.ml - модульные OUnit2 тесты
    └── property_tests.ml - QCheck2 тесты свойств
```

## Требования
### Функциональные

- Добавление элементов: add, add_many.

- Удаление элементов: remove (уменьшает счетчик, удаляет ветку при достижении 0).

- Фильтрация: filter.

- Отображение: map (с пересчетом позиции элементов).

- Свёртки: fold_left, fold_right, fold_with_counts.

- Моноид: Реализован neutral (пустое дерево) и merge (объединение счетчиков).

- Получение статистики: count, length.

### Нефункциональные
- Структуры данных неизменяемые (Immutable).

- Библиотека протестирована (Unit testing & Property-based testing).

- Эффективная реализация функции сравнения (без приведения к спискам).

- Идиоматичный стиль OCaml (использование Option, паттерн-матчинг, хвостовая рекурсия где применимо).

## Ключевые элементы реализации
### Интерфейс
```ocaml
module type Elt = sig
  type t
  val compare : t -> t -> int
  type component
  val compare_component : component -> component -> int
  val split : t -> component list
  val join : component list -> t
end

module type S = sig
  type elt
  type t
  val neutral : t
  val add : elt -> t -> t
  val remove : elt -> t -> t
  val merge : t -> t -> t
  val map : (elt -> elt) -> t -> t
  val filter : (elt -> bool) -> t -> t
  val fold_left : ('a -> elt -> 'a) -> 'a -> t -> 'a
  val fold_right : (elt -> 'a -> 'a) -> t -> 'a -> 'a
  val fold_with_counts : ('a -> elt * int -> 'a) -> 'a -> t -> 'a
  val equal : t -> t -> bool
  val compare : t -> t -> int
end
```

### Внутреннее представление
Узел дерева хранит количество завершений элемента в этой точке (count) и список дочерних узлов (children). Список детей всегда отсортирован по ключу компонента.
```ocaml
type child = { key : E.component; subtree : t }

and t = { 
  count : int;        (* Кратность элемента, заканчивающегося здесь *)
  children : child list 
}
```

### Каноничность представления
Для корректной работы структурного сравнения дерево не должно содержать "мертвых" веток (где count = 0 и нет детей). 
```ocaml
let rec clean_children = function
  | [] -> []
  | c :: cs -> 
      if is_empty c.subtree 
      then clean_children cs 
      else c :: clean_children cs
```

### Слияние (моноид)
Объединение двух деревьев происходит рекурсивно. Если пути совпадают, счетчики count складываются.
```ocaml
let rec merge t1 t2 =
  if t1 == t2 then t1
  else
    let new_count = max 0 (t1.count + t2.count) in
    (* Рекурсивное слияние списков детей *)
    { count = new_count
    ; children = clean_children (merge_ch t1.children t2.children) }
```

### Сравнение
Сравнение (equal и compare) проходит по дереву. Как только находится различие в count или в структуре детей, вычисление останавливается. Это намного быстрее сортировки списков.
```ocaml
let rec compare t1 t2 =
  let c = Int.compare t1.count t2.count in
  if c <> 0 then c else cmp_ch t1.children t2.children
```

## Использование
Пример создания мультимножества целых чисел, где числа разбиваются на цифры:
```ocaml
module IntElt = struct
  type t = int
  let compare = Int.compare
  type component = int
  let compare_component = Int.compare
  let split n = ... 
  let join l = ...
end

module IntTrie = Prefix_tree.Make(IntElt)

let t1 = IntTrie.of_list [1; 2; 2; 10]
let t2 = IntTrie.add 2 t1 

let count_of_2 = IntTrie.count 2 t2
```

## Тестирование
### Модульные тесты
Файл tests.ml проверяет базовую корректность:
add увеличивает счетчик, remove уменьшает.
merge корректно суммирует счетчики двух деревьев.
filter оставляет только нужные элементы.
equal и compare различают разные деревья и видят равенство одинаковых.

### Property-based
Файл property_tests.ml проверяет математические свойства на случайных данных:
- Ассоциативность merge: (a + b) + c = a + (b + c).
- Нейтральный элемент: a + empty = a.
- Add/Count: Добавление элемента x всегда увеличивает count x на 1.
- Map Identity: map id t == t.
- Consistency: Длина списка элементов равна length.
- Compare/Equal: Если compare возвращает 0, то equal истина.

## Выводы
В ходе выполнения лабораторной работы была реализована библиотека для работы с мультимножеством на основе префиксного дерева. 

Основные результаты:
1.  Использование системы модулей OCaml и функторов позволило создать полностью полиморфную структуру.
2.  Реализованы эффективные алгоритмы структурного сравнения и слияния, которые работают без предварительной линеаризации дерева, что повышает производительность. Структура удовлетворяет законам моноида.
3.  Корректность реализации подтверждена двумя уровнями тестирования: модульными тестами (OUnit2) для проверки API и property-based тестами (QCheck2) для верификации алгебраических свойств (ассоциативность, идемпотентность и др.).